# Engram V0.9.0 图系统开发计划

> **Last Modified**: 2026-01-13  
> **Goal**: 构建 "Event-Entity" 双层图谱，实现 Graph RAG 和可视化。

---

## 1. 核心目标 (Objectives)

V0.9.0 将补全 Engram 架构的最后一块拼图——**图结构**。

将现有的线性时间轴记忆升级为**网状关联记忆**，通过实体链接和因果关系增强召回深度。

### 1.1 关键交付物

| 交付物 | 说明 | 位置 |
|--------|------|------|
| **Entity Builder** | 自动从事件中提取实体和关系 | `services/graph/` |
| **Entity Config Panel** | 实体提取配置 UI | `views/Processing/` |
| **Graph View** | 交互式图谱可视化（dagre 布局 + LOD） | `views/MemoryStream/` (图谱 Tab) |
| **新宏 `{{engramGraph}}`** | 输出结构化的 EventNode JSON 供 AI 分析 | `tavern/MacroService.ts` |
| **Entity 提示词模板** | 新增 `entity_extraction` 分类模板 | `services/api/prompts/` |

---

## 2. 架构设计 (Architecture)

### 2.1 双层图谱模型 (Dual-Layer Graph)

采用 "事件-实体" (Event-Entity) 混合图结构：

```
Layer 1: 事件层 (Event Layer)
  ├─ 节点: EventNode (已存在)
  └─ 边: NEXT (时间序), CAUSED_BY (因果逻辑，来自 structured_kv.causality)

Layer 2: 实体层 (Entity Layer)
  ├─ 节点: EntityNode (角色/物品/地点/概念)
  └─ 边: INVOLVED_IN (参与事件), RELATED_TO (实体间关系)
```

### 2.2 数据结构定义

#### EntityNode (扩展 `services/types/graph.ts`)

```typescript
// 实体类型枚举
export enum EntityType {
    Character = 'char',      // 角色/人物
    Location = 'loc',        // 地点
    Item = 'item',           // 物品
    Concept = 'concept'      // 概念/组织/势力
}

// 实体节点
export interface EntityNode {
    id: string;                   // UUID
    name: string;                 // 实体名称 (主名称)
    type: EntityType;             // 实体类型
    description: string;          // 简短描述
    aliases: string[];            // 别名列表 (用于消歧)
    
    // 关联事件
    related_events: string[];     // 涉及的事件 ID 列表
    first_seen_event_id?: string; // 初次登场事件
    
    // 元数据
    significance: number;         // 重要度权重 (0.0-1.0)
    last_updated_at: number;      // 最后更新时间
    
    // ⭐ 布局持久化 (用户拖拽后保存位置)
    layout_x?: number;
    layout_y?: number;
}

// 图的边 (暂不持久化，运行时计算)
export interface GraphEdge {
    source: string;               // 起点 ID
    target: string;               // 终点 ID
    type: 'NEXT' | 'CAUSED_BY' | 'INVOLVED_IN' | 'RELATED_TO';
    weight: number;               // 边权重
    label?: string;               // 关系标签 (如 "持有", "敌对")
    metadata?: Record<string, unknown>;
}
```

### 2.3 触发机制设计 (复用 TrimConfig 模式)

> **参考**: `services/pipeline/EventTrimmer.ts` 的 `TrimConfig` 接口

```typescript
// 在 services/api/types.ts 新增，复用 Trim 的触发器模式
export interface EntityExtractConfig {
    /** 是否启用自动提取 */
    enabled: boolean;
    /** 触发器类型 (复用 Trim 模式) */
    trigger: 'count' | 'manual';
    /** 事件计数阈值 (默认 40) */
    countThreshold: number;
    /** 上次提取时的事件总数 (用于计算增量) */
    lastExtractedEventCount: number;
    /** 保留最近 N 条不处理 */
    keepRecentCount: number;
}

export const DEFAULT_ENTITY_CONFIG: EntityExtractConfig = {
    enabled: false,
    trigger: 'count',
    countThreshold: 40,
    lastExtractedEventCount: 0,
    keepRecentCount: 5,
};
```

---

## 3. 宏系统扩展

### 3.1 新宏 `{{engramGraph}}`

**用途**: 输出结构化的 EventNode JSON 供 AI 分析实体关系。

**输出格式** (排除 embedding 和系统字段):

```json
{
  "events": [
    {
      "id": "uuid",
      "summary": "高密度摘要文本",
      "structured_kv": {
        "time_anchor": "太阳历1023年春4月4日",
        "role": ["A", "B"],
        "location": "王城",
        "event": "战斗",
        "logic": ["转折", "危机"],
        "causality": "Chain"
      },
      "significance_score": 0.7,
      "level": 0,
      "source_range": { "start_index": 1, "end_index": 10 }
    }
  ],
  "existingEntities": [
    {
      "name": "Alice",
      "type": "char",
      "aliases": ["艾莉丝", "小艾"],
      "description": "女主角，冒险者"
    }
  ]
}
```

**实现位置**: `tavern/MacroService.ts`

```typescript
// 新增缓存和宏注册
private static cachedGraphData: string = '';

// 在 init() 中注册
context.registerMacro(
    'engramGraph',
    () => MacroService.cachedGraphData,
    'Engram: 事件和实体的结构化 JSON (用于图谱构建)'
);

/**
 * 刷新图谱数据缓存
 */
static async refreshGraphCache(): Promise<void> {
    const store = useMemoryStore.getState();
    const events = await store.getAllEvents();
    const entities = await store.getAllEntities(); // 需要在 memoryStore 添加
    
    // 过滤掉 embedding 等系统字段
    const cleanEvents = events.map(e => ({
        id: e.id,
        summary: e.summary,
        structured_kv: e.structured_kv,
        significance_score: e.significance_score,
        level: e.level,
        source_range: e.source_range,
    }));
    
    const cleanEntities = entities.map(e => ({
        name: e.name,
        type: e.type,
        aliases: e.aliases,
        description: e.description,
    }));
    
    this.cachedGraphData = JSON.stringify({
        events: cleanEvents,
        existingEntities: cleanEntities,
    }, null, 2);
}
```

---

## 4. 提示词模板系统扩展

### 4.1 新增分类 `entity_extraction`

**修改文件**: `services/api/types.ts`

```typescript
export type PromptCategory =
  | 'summary'
  | 'trim'
  | 'preprocessing'
  | 'entity_extraction';  // 新增

export const PROMPT_CATEGORIES = [
    // ... existing
    { 
        value: 'entity_extraction', 
        label: '实体提取', 
        description: '从事件中提取角色、地点、物品等实体' 
    },
];
```

### 4.2 内置提示词模板

**新建文件**: `services/api/prompts/entity_extraction.md`

> 系统角色定义：实体关系提取器  
> 核心任务：从剧情事件 JSON 中提取角色/地点/物品/概念等实体，识别实体间关系  
> 输出格式：JSON (entities, relations, entity_links)

### 4.3 模板变量

| 变量 | 说明 |
|------|------|
| `{{engramGraph}}` | 事件和已有实体的结构化 JSON |
| `{{worldbookContext}}` | 世界书激活内容 (提供背景设定) |
| `{{char}}` | 当前角色名 |

---

## 5. 服务层实现

### 5.1 EntityBuilder 服务

**新建文件**: `services/graph/EntityBuilder.ts`

```typescript
/**
 * EntityBuilder - 实体构建服务
 * 
 * 复用 EventTrimmer 的触发器模式
 */
export class EntityBuilder {
    private config: EntityExtractConfig;
    private isExtracting = false;
    
    /**
     * 检查是否应该触发实体提取 (复用 Trim canTrim 模式)
     */
    async shouldTrigger(): Promise<{ shouldTrigger: boolean; eventCount: number; pendingCount: number }> {
        if (!this.config.enabled) return { shouldTrigger: false, eventCount: 0, pendingCount: 0 };
        if (this.config.trigger !== 'count') return { shouldTrigger: false, eventCount: 0, pendingCount: 0 };
        
        const store = useMemoryStore.getState();
        const events = await store.getAllEvents();
        const currentCount = events.length;
        const lastCount = this.config.lastExtractedEventCount;
        const pendingCount = currentCount - lastCount;
        
        return {
            shouldTrigger: pendingCount >= this.config.countThreshold,
            eventCount: currentCount,
            pendingCount,
        };
    }
    
    /**
     * 执行实体提取
     */
    async extract(manual = false): Promise<EntityNode[] | null> {
        if (this.isExtracting) {
            Logger.warn('EntityBuilder', '正在执行提取，跳过本次触发');
            return null;
        }
        
        this.isExtracting = true;
        try {
            // 1. 刷新宏缓存
            await MacroService.refreshGraphCache();
            
            // 2. 获取提示词模板
            const template = SettingsManager.getEnabledPromptTemplate('entity_extraction');
            
            // 3. 调用 LLM
            const response = await llmAdapter.generate({
                systemPrompt: template.systemPrompt,
                userPrompt: template.userPromptTemplate
                    .replace('{{engramGraph}}', MacroService.cachedGraphData)
                    .replace('{{worldbookContext}}', MacroService.cachedWorldbookContext)
            });
            
            // 4. 解析并保存实体
            const parsed = RobustJsonParser.parse(response.content);
            return this.saveEntities(parsed.entities, parsed.entity_links);
            
        } finally {
            this.isExtracting = false;
        }
    }
    
    /**
     * 实体消歧: 检查新实体是否与已有实体重复
     */
    private async resolveEntity(newEntity: Partial<EntityNode>): Promise<EntityNode | null> {
        const store = useMemoryStore.getState();
        const existing = await store.getAllEntities();
        
        // 精确名称匹配 或 别名匹配
        return existing.find(e => 
            e.name === newEntity.name || 
            e.aliases?.includes(newEntity.name!) ||
            newEntity.aliases?.some(a => e.aliases?.includes(a))
        ) || null;
    }
}

export const entityBuilder = new EntityBuilder();
```

### 5.2 集成到 Pipeline

**修改文件**: `services/pipeline/Pipeline.ts`

```typescript
// 在 run() 方法末尾添加
// 6. 检查是否触发实体提取 (复用 Trim 触发检测模式)
const { entityBuilder } = await import('@/services/graph/EntityBuilder');
const { shouldTrigger } = await entityBuilder.shouldTrigger();
if (shouldTrigger) {
    Logger.info('Pipeline', '触发实体提取');
    await entityBuilder.extract();
}
```

---

## 6. UI 层实现

### 6.1 Processing 视图 - 实体提取配置

**新建文件**: `views/Processing/EntityConfigPanel.tsx`

> 在 Processing 视图添加实体提取配置面板（与 Trim 配置类似）

```tsx
export const EntityConfigPanel: React.FC = () => {
    const [config, setConfig] = useState<EntityExtractConfig>(DEFAULT_ENTITY_CONFIG);
    const [status, setStatus] = useState({ eventCount: 0, pendingCount: 0 });
    const [isExtracting, setIsExtracting] = useState(false);
    
    return (
        <Card>
            <CardHeader>
                <CardTitle className="flex items-center gap-2">
                    <Network size={18} />
                    实体提取
                </CardTitle>
            </CardHeader>
            <CardContent className="space-y-4">
                {/* 启用开关 */}
                <div className="flex items-center justify-between">
                    <span>启用自动提取</span>
                    <Switch checked={config.enabled} onCheckedChange={...} />
                </div>
                
                {/* 触发阈值 */}
                <div className="flex items-center gap-2">
                    <span>每</span>
                    <Input type="number" value={config.countThreshold} className="w-20" />
                    <span>条新事件触发一次</span>
                </div>
                
                {/* 状态显示 */}
                <div className="text-sm text-muted-foreground">
                    当前事件: {status.eventCount} | 待处理: {status.pendingCount}
                </div>
                
                {/* 手动触发按钮 */}
                <Button onClick={handleManualExtract} disabled={isExtracting}>
                    {isExtracting ? '提取中...' : '立即提取实体'}
                </Button>
            </CardContent>
        </Card>
    );
};
```

### 6.2 MemoryStream 视图 - 图谱可视化

> **位置**: `views/MemoryStream/index.tsx` 的 `viewTab === 'graph'` 分支

#### 6.2.1 视觉隐喻 (Visual Metaphor)

- **主轴 (Mainline)**: Event 节点通过 NEXT 边连接，形成垂直时间轴
- **分支 (Branches)**: Entity 节点通过 INVOLVED_IN 边展开，像树枝
- **跨越 (Crossovers)**: Entity 间的 RELATED_TO 形成横向连线

#### 6.2.2 自动布局 (dagre)

**新建文件**: `views/MemoryStream/layoutHelper.ts`

```typescript
import dagre from 'dagre';
import { Node, Edge, Position } from '@xyflow/react';

const dagreGraph = new dagre.graphlib.Graph();
dagreGraph.setDefaultEdgeLabel(() => ({}));

export const getLayoutedElements = (nodes: Node[], edges: Edge[], direction = 'TB') => {
    const isHorizontal = direction === 'LR';
    dagreGraph.setGraph({ rankdir: direction });

    // 1. 注册节点 (Event 宽，Entity 窄)
    nodes.forEach((node) => {
        const width = node.type === 'event' ? 250 : 150;
        const height = node.type === 'event' ? 100 : 50;
        dagreGraph.setNode(node.id, { width, height });
    });

    // 2. 注册边
    edges.forEach((edge) => {
        dagreGraph.setEdge(edge.source, edge.target);
    });

    // 3. 计算布局
    dagre.layout(dagreGraph);

    // 4. 应用坐标回 React Flow 节点
    const layoutedNodes = nodes.map((node) => {
        const nodeWithPosition = dagreGraph.node(node.id);
        return {
            ...node,
            targetPosition: isHorizontal ? Position.Left : Position.Top,
            sourcePosition: isHorizontal ? Position.Right : Position.Bottom,
            position: {
                x: nodeWithPosition.x - nodeWithPosition.width / 2,
                y: nodeWithPosition.y - nodeWithPosition.height / 2,
            },
        };
    });

    return { nodes: layoutedNodes, edges };
};
```

#### 6.2.3 语义缩放 (LOD - Level of Detail)

| 级别 | 缩放范围 | Event 显示 | Entity 显示 | 边显示 |
|------|----------|------------|-------------|--------|
| **LOD 0** | zoom < 0.4 | 仅圆点/时间戳 | 隐藏或头像微缩 | 仅 NEXT 主线 |
| **LOD 1** | 0.4 ≤ zoom ≤ 1.0 | 标题 + 日期 + 重要性 | 头像 + 名称 | 所有连线 |
| **LOD 2** | zoom > 1.0 | 完整 Summary + Tags | 描述 + 更新时间 | 连线显示关系标签 |

**自定义节点组件**: `views/MemoryStream/CustomNodes/EventNode.tsx`

```tsx
const EventNode = ({ data }: NodeProps) => {
  const zoom = useStore(s => s.transform[2]);

  if (zoom < 0.4) return <DotView data={data} />;
  if (zoom > 1.0) return <FullDetailView data={data} />;
  return <SummaryCardView data={data} />;
};
```

#### 6.2.4 用户交互

| 操作 | 行为 |
|------|------|
| **拖拽** | 更新 `layout_x`, `layout_y` (持久化) |
| **连线** | 弹出 Modal 选择关系类型 → 创建新关系 |
| **删除** | Backspace 删除，同步 DB |
| **点击** | 右侧弹出 DetailPanel |
| **Auto Layout** | 重新执行 dagre 布局 |

---

## 7. 文件变更清单

### 7.1 新增文件

| 文件 | 说明 |
|------|------|
| `services/graph/EntityBuilder.ts` | 实体构建核心服务 |
| `services/api/prompts/entity_extraction.md` | 实体提取提示词模板 |
| `views/Processing/EntityConfigPanel.tsx` | 实体提取配置面板 |
| `views/MemoryStream/GraphView.tsx` | 图谱可视化主容器 |
| `views/MemoryStream/GraphToolbar.tsx` | 图谱工具栏 |
| `views/MemoryStream/layoutHelper.ts` | dagre 布局辅助 |
| `views/MemoryStream/CustomNodes/EventNode.tsx` | 事件节点 (LOD) |
| `views/MemoryStream/CustomNodes/EntityNode.tsx` | 实体节点 (LOD) |
| `views/MemoryStream/CustomEdges/TimeEdge.tsx` | 时间线边 (NEXT) |
| `views/MemoryStream/CustomEdges/LogicEdge.tsx` | 逻辑边 (INVOLVED_IN) |

### 7.2 修改文件

| 文件 | 变更 |
|------|------|
| `services/types/graph.ts` | 添加 `EntityType` 枚举，完善 `EntityNode` 字段 (`aliases`, `layout_x/y`) |
| `services/api/types.ts` | 添加 `entity_extraction` 分类，添加 `EntityExtractConfig` |
| `services/database/db.ts` | 确认 `entities` 表索引 |
| `tavern/MacroService.ts` | 新增 `{{engramGraph}}` 宏注册，添加 `refreshGraphCache()` |
| `services/pipeline/Pipeline.ts` | 添加实体提取触发逻辑 |
| `views/Processing/ProcessingView.tsx` | 集成 `EntityConfigPanel` |
| `views/MemoryStream/index.tsx` | 实现图谱 Tab (替换占位符) |
| `views/APIPresets/components/PromptTemplateCard.tsx` | 添加 `entity_extraction` 颜色 |
| `stores/memoryStore.ts` | 添加 `getAllEntities`, `saveEntity` 等方法 |
| `services/settings/Persistence.ts` | 添加 `entityExtractConfig` 存储 |
| `package.json` | 添加 `dagre`, `@xyflow/react` 依赖 |

---

## 8. 开发阶段

### Phase 1: 数据层 (Day 1)

- [ ] 完善 `EntityNode` 类型定义 (添加 `aliases`, `layout_x/y`)
- [ ] 添加 `EntityExtractConfig` 配置类型 (复用 TrimConfig 模式)
- [ ] 确认 `entities` 表索引正确
- [ ] 在 `memoryStore` 添加 `getAllEntities`, `saveEntity` 方法
- [ ] 添加 `entityExtractConfig` 持久化

### Phase 2: 宏系统 + 提示词 (Day 2)

- [ ] 实现 `{{engramGraph}}` 宏
- [ ] 添加 `refreshGraphCache()` 方法
- [ ] 编写 `entity_extraction.md` 提示词
- [ ] 添加 `entity_extraction` 分类到类型系统
- [ ] 注册内置提示词模板

### Phase 3: EntityBuilder 服务 (Day 2-3)

- [ ] 实现 `EntityBuilder.ts` 核心逻辑
- [ ] 实现触发器检测 (`shouldTrigger`)
- [ ] 实现实体消歧 (`resolveEntity`)
- [ ] 集成到 `Pipeline.ts`

### Phase 4: Processing UI (Day 3)

- [ ] 实现 `EntityConfigPanel.tsx`
- [ ] 集成到 ProcessingView

### Phase 5: 图谱可视化 (Day 4-5)

- [ ] 安装 `dagre`, `@xyflow/react`
- [ ] 实现 `layoutHelper.ts`
- [ ] 实现 `CustomNodes/EventNode.tsx` (LOD)
- [ ] 实现 `CustomNodes/EntityNode.tsx` (LOD)
- [ ] 实现 `CustomEdges/TimeEdge.tsx`, `LogicEdge.tsx`
- [ ] 实现 `GraphView.tsx`
- [ ] 实现 `GraphToolbar.tsx` (Auto Layout 按钮)
- [ ] 集成到 MemoryStream 图谱 Tab

### Phase 6: 测试与调优 (Day 6)

- [ ] 集成测试：Summary → Entity 全流程
- [ ] 测试图谱交互（拖拽、连线、缩放）
- [ ] 测试 LOD 切换
- [ ] 调优提示词模板

---

## 9. 验证计划

### 9.1 手动测试步骤

1. **配置测试** (Processing → 实体配置)
   - 确认可以切换启用/禁用
   - 确认可以修改触发阈值
   - 确认状态显示正确

2. **提示词模板测试** (API 预设 → 提示词模板)
   - 确认"实体提取"分类显示
   - 确认内置模板可查看/编辑
   - 确认 `{{engramGraph}}` 变量可用

3. **手动提取测试**
   - 确保有 10+ 条事件摘要
   - 点击"立即提取实体"
   - 确认实体保存到数据库

4. **自动触发测试**
   - 设置阈值为 5
   - 连续进行 5 轮对话触发摘要
   - 确认自动执行实体提取

5. **图谱可视化测试** (MemoryStream → 图谱 Tab)
   - 确认节点正确渲染
   - 测试 Auto Layout 按钮
   - 测试拖拽节点并刷新（位置应保持）
   - 测试缩放查看 LOD 切换

### 9.2 需要用户协助

- 运行 `npm run build` 确认无编译错误
- 在 SillyTavern 中实际测试对话流程

---

## 10. 后续规划 (V0.10+)

| 版本 | 功能 |
|------|------|
| V0.10 | Graph RAG: `GraphRetriever` 基于图游走的上下文扩展 |
| V0.11 | Entity Timeline: 实体事件时间线视图 |
| V0.12 | 实体关系编辑器增强 |
